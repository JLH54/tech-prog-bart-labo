recusivite

1 - travailler un peu
2- Condition de fin

int func(int n){
	if(n ==0) return;
	func(n-1);

}
dfs
1 verifier si ma stack est vide, sinon on pop l'element du top

2 Dans un algorithme de recherche on aurait une comparaison, comme exemple, si le character est F on 
   a trouver le noeud puis on retournerais le noeud
   
3 apres la comparaison, on considere ce noeud comme le noeud courant et on push le right puis le left,
  on push le left en dernier puisque l'on veut
  aller en profondeur avant d'aller latteralement. On recommence
  
 bfs
 1 verifier si ma queue est vide sinon on pop l'element de fin
 
 2 dans un algorithme de recheche on aurait une comparaison, comme exemple,si le character est F on a trouver le noeud
   puis on retournerais le noeud
 
 3 apres la comparaison, on cnsidere ce noeud comme le noeud courant et on push le left puis le right. On recommence.
 
 q->push(a)
 while(q->prev != NULL)
 {
	TreeNode* n = pop(a)
	if (n->data == "F") return n;
	push(q, n->left);
	push(q, n->right);
 }